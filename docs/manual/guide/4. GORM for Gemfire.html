<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>4. GORM for Gemfire</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="4. GORM for Gemfire">4. GORM for Gemfire</a></h1>The Gemfire plugin for Grails allows you to map GORM entities onto Gemfire.<p class="paragraph"/>The following key features are supported by GORM for Gemfire:
<ul class="star">
<li>Simple persistence methods</li>
<li>Dynamic finders</li>
<li>Criteria queries</li>
<li>Named queries</li>
<li>Inheritance</li>
</ul><p class="paragraph"/>However, some features are not supported:
<ul class="star">
<li>HQL queries (Gemfire OQL is supported however)</li>
<li>Dirty checking methods</li>
<li>Composite primary keys</li>
<li>Many-to-many associations (these can be modelled with a mapping class)</li>
<li>Any direct interaction with the Hibernate API</li>
<li>Custom Hibernate user types</li>
</ul><p class="paragraph"/><h2><a name="4.1 Getting Started">4.1 Getting Started</a></h2>If you plan to use Gemfire as your primary datastore then you need to uninstall the Hibernate plugin:<p class="paragraph"/><div class="code"><pre>grails uninstall&#45;plugin hibernate</pre></div><p class="paragraph"/>With this done all domain classes in grails-app/domain will be persisted via Gemfire and not Hibernate. You can create a domain class by running the regular <code>create-domain-class</code> command:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class Person</pre></div><p class="paragraph"/>With that done you need to make sure your <code>Person</code> domain class implements the <code>Serializable</code> interface:<p class="paragraph"/><div class="code"><pre>class Person <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>The <code>Person</code> domain class will automatically be a persistent entity that can be stored in Gemfire.<h2><a name="4.2 Combining Hibernate and Gemfire">4.2 Combining Hibernate and Gemfire</a></h2>If you have both the Hibernate and Gemfire plugins installed then by default all classes in the <code>grails-app/domain</code> directory will be persisted by Hibernate and not Gemfire. If you want to persist a particular domain class with Gemfire then you must use the <code>mapWith</code> property in the domain class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mapWith = <span class="java&#45;quote">"gemfire"</span></pre></div><p class="paragraph"/>Alternatively you can persist Hibernate entities to Gemfire using the special <code>gemfire</code> scope added to all Hibernate entities:<p class="paragraph"/><div class="code"><pre>def hibernatePerson = Person.get(1)<p class="paragraph"/>hibernatePerson.gemfire.save()<p class="paragraph"/>def redisPerson = Person.gemfire.get(1)</pre></div><p class="paragraph"/>This makes it really easy to use Gemfire as a cache for Hibernate entities.<h2><a name="4.3 Mapping Entities to Regions">4.3 Mapping Entities to Regions</a></h2>GORM for Gemfire maps each domain class to a Gemfire region in the configured cache. You can configure the attributes of the region using the static mapping block:<p class="paragraph"/><div class="code"><pre>class Person <span class="java&#45;keyword">implements</span> Serializable &#123;
  <span class="java&#45;object">String</span> name<p class="paragraph"/>  <span class="java&#45;keyword">static</span> mapping = &#123;
    dataPolicy DataPolicy.PARTITION
    region <span class="java&#45;quote">"people"</span>
  &#125;
&#125;</pre></div><p class="paragraph"/>The available configuration options can be found in the API of the <a href="http://www.gemstone.com/docs/current/product/docs/japi/com/gemstone/gemfire/cache/AttributesFactory.html" target="blank">AttributesFactory</a> class. For example the <code>dataPolicy</code> setting specific in the above examples maps to the <code>setDataPolicy</code> method of the <code>AttributesFactory</code> class.
<h2><a name="4.4 Using Cache Servers">4.4 Using Cache Servers</a></h2>A described in the section on <a href="../guide/single.html#3. Cache Servers" class="guide">cache servers</a>, you can setup Gemfire in client / server mode, however to do so with GORM entities the server needs to know about the regions and also needs to have all the necessary classes on the classpath.<p class="paragraph"/>The Gemfire plugin for Grails will handle both of these cases for you. First to setup an appropriate server configuration you should run in the <code>gemfire-generate</code> command:<p class="paragraph"/><div class="code"><pre>$ grails gemfire&#45;generate</pre></div><p class="paragraph"/>This will create a <code>target/cache.xml</code> file with regions that match the GORM entities you have created.<p class="paragraph"/>With this done you can start a cache server with the <code>start-cache-server</code> command:<p class="paragraph"/><div class="code"><pre>$ grails start&#45;cache&#45;server server1 &#45;&#45;port=4111</pre></div><p class="paragraph"/>The <code>start-cache-server</code> command will check for the existence of a <code>grails-app/conf/cache.xml</code> or the generated <code>target/cache.xml</code> file. This allows you to make customizations to the generated file if necessary.<p class="paragraph"/>The <code>start-cache-server</code> command will also make sure that the classes in your Grails application are visible on the cache server. Once you have the cache server up and running you need to configure your Grails application to use the server by adding the following to <code>grails-app/conf/Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>// grails&#45;app/conf/Config.groovy
grails.gemfire.servers = &#123;    
	myServer &#123;
		properties = &#91;'log&#45;level': 'warning'&#93;
		pool &#123;
			addServer <span class="java&#45;quote">"localhost"</span>, 4111
			setMinConnections 1
			setMaxConnections 20
			setRetryAttempts 10
			setSubscriptionEnabled <span class="java&#45;keyword">true</span>
		&#125;
	&#125;
&#125;</pre></div><h2><a name="4.5 Continuous Queries">4.5 Continuous Queries</a></h2>Continuous queries are a feature of Gemfire that allows a client to subscribe to cache events using a query.<p class="paragraph"/>To use continuous queries you need to have a <a href="../guide/single.html#3. Cache Servers" class="guide">Cache Server</a> running with <code>subscriptionEnabled</code> set to <code>true</code> (see the configuration in the previous section). Then simply use the <code>cq</code> namespace to execute a dynamic finder that takes a closure:<p class="paragraph"/><div class="code"><pre>Person.cq.findAllByLastName(<span class="java&#45;quote">"Flintstone"</span>) &#123; event &#45;&#62;
			println <span class="java&#45;quote">"GOT EVENT $event"</span>
&#125;</pre></div><p class="paragraph"/>The above will execute a continuous query that fires every time a <code>Person</code> with the surname "Flinstone" is inserted or updated in the cache. The <code>event</code> object is an instance of <a href="http://www.gemstone.com/docs/current/product/docs/japi/com/gemstone/gemfire/cache/query/CqEvent.html" target="blank">CqEvent</a> which contains methods to get the value and the operation that triggered the event.<p class="paragraph"/>Typically you would write an event handler that checks if an exception was thrown:<p class="paragraph"/>
<div class="code"><pre>Person.cq.findAllByLastName(<span class="java&#45;quote">"Flintstone"</span>) &#123; event &#45;&#62;
	<span class="java&#45;keyword">if</span>(!event.throwable) &#123;
		println <span class="java&#45;quote">"NEW FLINSTONE $&#123;event.newValue.firstName&#125;"</span>
	&#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>
<h2><a name="4.6 Grid Computing">4.6 Grid Computing</a></h2>Using a partitioned topology Gemfire will store a primary version of an entity on one node and a backup on another node. This means that a particular entity might be stored on a completely different machine to where the client is running.<p class="paragraph"/>You may want to execute some logic that manipulates the primary version of an entity. This is where Gemfire's function execution functionality comes in handy.<p class="paragraph"/>For example say you save an entity on one node in the Grid:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Plant(name:<span class="java&#45;quote">"cabbage"</span>, goesInPatch:<span class="java&#45;keyword">true</span>).save()</pre></div><p class="paragraph"/>You can later execute a function that operates on the local data where the node is stored using the <code>executeFunction</code> method:<p class="paragraph"/><div class="code"><pre>def results = Plant.executeFunction(&#91;p.id&#93;) &#123; ctx &#45;&#62;
  ctx.lastResult ctx.localData&#91;ctx.filter.iterator().next()&#93;
&#125;
assert results&#91;0&#93;.name == 'cabbage'</pre></div><p class="paragraph"/>The <code>executeFunction</code> method takes a <code>List</code> (which acts as a filter to specify which entities you want to execute the function for) and a closure which is the function to execute.<p class="paragraph"/>What actually happens is the Groovy closure is serialized across the grid and executed on the node where the data exists. The <code>ctx.localData</code> variable gives you access to the data stored locally on the node.<p class="paragraph"/>In this example we're just returning the data from the function as part of the execution by calling the <code>lastResult</code> method on the <a href="http://www.gemstone.com/docs/current/product/docs/japi/com/gemstone/gemfire/cache/execute/RegionFunctionContext.html" target="blank">FunctionContext</a> which relays to the <a href="http://www.gemstone.com/docs/current/product/docs/japi/com/gemstone/gemfire/cache/execute/ResultSender.html" target="blank">ResultSender</a><p class="paragraph"/>
Using this mechanism you can implement typical grid computing patterns such as Map/Reduce.<p class="paragraph"/><h2><a name="4.7 OQL Queries">4.7 OQL Queries</a></h2>GORM for Gemfire does not support string-based HQL queries (which are specific to Hibernate) instead you can execute OQL queries:<p class="paragraph"/><div class="code"><pre>def results = Plant.findAll(<span class="java&#45;quote">"goesInPatch = <span class="java&#45;keyword">false</span>"</span>, &#91;sort:'name'&#93;)</pre></div><p class="paragraph"/>Or<p class="paragraph"/><div class="code"><pre>def result = Plant.find('name = $1', &#91;'rose'&#93;)</pre></div><p class="paragraph"/>See section of the <a href="http://www.gemstone.com/docs/current/product/docs/html/Manuals/DevelopersGuide/wwhelp/wwhimpl/common/html/wwhelp.htm#context=DevelopersGuide&#38;file=Querying.14.1.html%231295271" target="blank">Gemfire Query Language</a> for more information.
    </body>
</html>
