Using a partitioned topology Gemfire will store a primary version of an entity on one node and a backup on another node. This means that a particular entity might be stored on a completely different machine to where the client is running.

You may want to execute some logic that manipulates the primary version of an entity. This is where Gemfire's function execution functionality comes in handy.

For example say you save an entity on one node in the Grid:

{code}
      def p = new Plant(name:"cabbage", goesInPatch:true).save()
{code}

You can later execute a function that operates on the local data where the node is stored using the @executeFunction@ method:

{code}
def results = Plant.executeFunction([p.id]) { ctx ->
  ctx.lastResult ctx.localData[ctx.filter.iterator().next()]
}
assert results[0].name == 'cabbage'
{code}

The @executeFunction@ method takes a @List@ (which acts as a filter to specify which entities you want to execute the function for) and a closure which is the function to execute.

What actually happens is the Groovy closure is serialized across the grid and executed on the node where the data exists. The @ctx.localData@ variable gives you access to the data stored locally on the node.

In this example we're just returning the data from the function as part of the execution by calling the @lastResult@ method on the "FunctionContext":http://www.gemstone.com/docs/current/product/docs/japi/com/gemstone/gemfire/cache/execute/RegionFunctionContext.html which relays to the "ResultSender":http://www.gemstone.com/docs/current/product/docs/japi/com/gemstone/gemfire/cache/execute/ResultSender.html


Using this mechanism you can implement typical grid computing patterns such as Map/Reduce.

